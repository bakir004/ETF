{"id":0,"name":"Tehnike programiranja, Z2, Zadatak 2","version":"3","languages":["C++"],"tools":{"compile":{"require":"g++","features":["optimize","warn","pedantic","C++14"]},"compile[debug]":{"require":"g++","features":["debug","C++14","asan"]},"execute":{"require":"asan"},"debug":[],"profile[asan]":{"require":"asan","input_file":"stderr.txt","fast":true}},"prepare":["compile"],"tests":[{"tools":[{"patch":[{"position":"top_of_file","code":"//---------------------------------------------------------------------------------------------------------------\n// Tehnike programiranja - Akademska 2023/2024 godina\n// Zadaca 2 - Zadatak 2\n// Odgovorni asistent: Vahidin Hasi\u0107 - vhasic1@etf.unsa.ba\n// Za sva tehnicka pitanja vezana za autotestove za zadatak 2, obratite se na navedeni mail.\n//---------------------------------------------------------------------------------------------------------------"},{"position":"main","code":"_main();"}]},"compile[debug]",{"execute":{"expect":["Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:\n 12   9  45  -4  -3 -15 \n  0 -15   6   0   5  -2 \n  0   0   0  20  15  75 \n  0   0   0   0 -25  10","Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:\n 12   9  45  -4  -3 -15 \n  0 -15   6  -0   5  -2 \n  0   0   0  20  15  75 \n  0  -0   0   0 -25  10"],"environment":{"stdin":"2 2\n3 -1 0 5\n2 3\n4 3 15 0 -5 2\n"}}},"debug","profile[asan]"],"name":"Test 1","id":1},{"tools":[{"patch":[{"position":"main","code":"    std::vector<std::vector<int>> mat1 = {{1, 2}, {3}};\n    std::vector<std::vector<int>> mat2 = {{4, 5}, {6, 7}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n\n    mat1 = std::vector<std::vector<int>> {{1, 2}, {3, 4}};\n    mat2 = std::vector<std::vector<int>>{{5}, {6, 7}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n\n    mat1 = std::vector<std::vector<int>> {};\n    mat2 = std::vector<std::vector<int>>{};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &e)\n    {\n        std::cout << e.what() << std::endl;\n    }"}]},"compile[debug]",{"execute":{"expect":["Prvi parametar nema formu matrice\nDrugi parametar nema formu matrice\nParametri nemaju formu matrice"]}},"debug","profile[asan]"],"name":"Test 2","id":2,"options":["hidden"]},{"tools":[{"patch":[{"position":"main","code":"    std::vector<int> m1[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    std::vector<int> m2[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)\n                                                    { return x * y; });\n    for (const auto &row : result)\n    {\n        for (const auto &elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }"}]},"compile[debug]",{"execute":{"expect":["1 2 3 2 4 6 3 6 9\n4 5 6 8 10 12 12 15 18\n7 8 9 14 16 18 21 24 27\n4 8 12 5 10 15 6 12 18\n16 20 24 20 25 30 24 30 36\n28 32 36 35 40 45 42 48 54 \n7 14 21 8 16 24 9 18 27\n28 35 42 32 40 48 36 45 54\n49 56 63 56 64 72 63 72 81"]}},"debug","profile[asan]"],"name":"Test 3","id":3,"options":["hidden"]},{"tools":[{"patch":[{"position":"main","code":"    std::vector<std::vector<int>> mat1 = {{3, -1}, {0, 5}};\n    std::vector<std::vector<int>> mat2 = {{4, 3, 15}, {0, -5, 2}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { if (y == 0) throw std::runtime_error(\"Dijeljenje s nulom\");\n                                                            return x / y; });\n    }\n    catch (std::runtime_error &e)\n    {\n        std::cout << e.what() << std::endl;\n    }"}]},"compile[debug]",{"execute":{"expect":["Neocekivani problemi pri racunanju"]}},"debug","profile[asan]"],"name":"Test 4","id":4,"options":["hidden"]},{"tools":[{"patch":[{"position":"main","code":"    int m = 2, n = 3;\n    int p = 3, q = 4;\n    int mat1[2][3] = {{3, 5, 2}, {4, 0, -1}};\n    int mat2[3][4] = {{1, 4, -2, 3}, {0, 5, 4, 1}, {2, 0, 0, 3}};\n\n    std::vector<std::vector<int>> kronekerovProizvod = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                                                         { return x * y; });\n\n    for (int i = 0; i < m * p; i++)\n    {\n        for (int j = 0; j < n * q; j++)\n        {\n            std::cout << kronekerovProizvod[i][j] << \" \";\n        }\n        std::cout << std::endl;\n    }"}]},"compile[debug]",{"execute":{"expect":["3 12 -6 9 5 20 -10 15 2 8 -4 6\n0 15 12 3 0 25 20 5 0 10 8 2\n6 0 0 9 10 0 0 15 4 0 0 6\n4 16 -8 12 0 0 0 0 -1 -4 2 -3\n0 20 16 4 0 0 0 0 0 -5 -4 -1\n8 0 0 12 0 0 0 0 -2 0 0 -3"]}},"debug","profile[asan]"],"name":"Test 5","id":5,"options":["hidden"]},{"tools":[{"patch":[{"position":"main","code":"    std::deque<std::deque<int>> mat1 = {{3, -1}, {1, 5}};\n    std::deque<std::deque<double>> mat2 = {{4.2, 3.1, 15.4}, {1.02, -5.8, 2.6}};\n    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)\n                                                    { return x + y; });\n    for (const auto &row : result)\n    {\n        for (const auto &elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }"}]},"compile[debug]",{"execute":{"expect":["7.2 6.1 18.4 3.2 2.1 14.4\n4.02 -2.8 5.6 0.02 -6.8 1.6\n5.2 4.1 16.4 9.2 8.1 20.4\n2.02 -4.8 3.6 6.02 -0.8 7.6"]}},"debug","profile[asan]"],"name":"Test 6","id":6},{"tools":[{"patch":[{"position":"main","code":"    int mat1[2][2] = {{3, -1}, {4, 5}};\n    std::deque<std::deque<double>> mat2 = {{4.5, 3.5, 15.5}, {0.5, -5.5, 2.5}};\n    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)\n                                                    { return x * y; });\n    for (const auto &row : result)\n    {\n        for (const auto &elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }"}]},"compile[debug]",{"execute":{"expect":["13.5 10.5 46.5 -4.5 -3.5 -15.5 \n1.5 -16.5 7.5 -0.5 5.5 -2.5\n18 14 62 22.5 17.5 77.5\n2 -22 10 2.5 -27.5 12.5"]}},"debug","profile[asan]"],"name":"Test 7","id":7,"options":["hidden"]},{"tools":[{"patch":[{"position":"above_main","code":"#include <list>\n\ntemplate <typename TipElemenata>\nclass Pristupnik\n{\n    std::list<TipElemenata> &red;\n\npublic:\n    Pristupnik(std::list<TipElemenata> &red) : red(red) {}\n    TipElemenata &operator[](int j) { return *std::next(red.begin(), j); }\n    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }\n    auto begin() const { return red.begin(); }\n    auto end() const { return red.end(); }\n};\n\ntemplate <typename TipElemenata>\nclass SugavaMatrica\n{\n    std::list<std::list<TipElemenata>> mat;\n\npublic:\n    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}\n    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    auto begin() const { return mat.begin(); }\n    auto end() const { return mat.end(); }\n};"},{"position":"main","code":"    SugavaMatrica<int> m1(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m1[i][j] = (i + 1) * (j + 1);\n\n    SugavaMatrica<int> m2(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m2[i][j] = (i + 1) + (j + 1);\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)\n                                                    { return x * y; });\n    for (const auto &row : result)\n    {\n        for (const auto &elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }"}]},"compile[debug]",{"execute":{"expect":["2 3 4 4 6 8 6 9 12\n3 4 5 6 8 10 9 12 15\n4 5 6 8 10 12 12 15 18\n4 6 8 8 12 16 12 18 24\n6 8 10 12 16 20 18 24 30\n8 10 12 16 20 24 24 30 36\n6 9 12 12 18 24 18 27 36\n9 12 15 18 24 30 27 36 45\n12 15 18 24 30 36 36 45 54"]}},"debug","profile[asan]"],"name":"Test 8","id":8,"options":["hidden"]},{"tools":[{"patch":[{"position":"above_main","code":"#include <list>\n\ntemplate <typename TipElemenata>\nclass Pristupnik\n{\n    std::list<TipElemenata> &red;\n\npublic:\n    Pristupnik(std::list<TipElemenata> &red) : red(red) {}\n    TipElemenata &operator[](int j) { return *std::next(red.begin(), j); }\n    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }\n    auto begin() const { return red.begin(); }\n    auto end() const { return red.end(); }\n};\n\ntemplate <typename TipElemenata>\nclass SugavaMatrica\n{\n    std::list<std::list<TipElemenata>> mat;\n\npublic:\n    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}\n    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    auto begin() const { return mat.begin(); }\n    auto end() const { return mat.end(); }\n};"},{"position":"main","code":"    SugavaMatrica<int> m1(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m1[i][j] = (i + 1) * (j + 1);\n\n    SugavaMatrica<double> m2(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m2[i][j] = (i + 2.5) + (j + 1);\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, double y)\n                                                    { return x + y; });\n    for (const auto &row : result)\n    {\n        for (const auto &elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }"}]},"compile[debug]",{"execute":{"expect":["4.5 5.5 6.5 5.5 6.5 7.5 6.5 7.5 8.5\n5.5 6.5 7.5 6.5 7.5 8.5 7.5 8.5 9.5\n6.5 7.5 8.5 7.5 8.5 9.5 8.5 9.5 10.5\n5.5 6.5 7.5 7.5 8.5 9.5 9.5 10.5 11.5\n6.5 7.5 8.5 8.5 9.5 10.5 10.5 11.5 12.5\n7.5 8.5 9.5 9.5 10.5 11.5 11.5 12.5 13.5\n6.5 7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5\n7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5\n8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5 16.5"]}},"debug","profile[asan]"],"name":"Test 9","id":9,"options":["hidden"]}],"code":"200"}