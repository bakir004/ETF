<input type="hidden" name="task" value="{&quot;id&quot;:0,&quot;name&quot;:&quot;Tehnike programiranja, Z2, Zadatak 2&quot;,&quot;version&quot;:&quot;3&quot;,&quot;languages&quot;:[&quot;C++&quot;],&quot;tools&quot;:{&quot;compile&quot;:{&quot;require&quot;:&quot;g++&quot;,&quot;features&quot;:[&quot;optimize&quot;,&quot;warn&quot;,&quot;pedantic&quot;,&quot;C++14&quot;]},&quot;compile[debug]&quot;:{&quot;require&quot;:&quot;g++&quot;,&quot;features&quot;:[&quot;debug&quot;,&quot;C++14&quot;,&quot;asan&quot;]},&quot;execute&quot;:{&quot;require&quot;:&quot;asan&quot;},&quot;debug&quot;:[],&quot;profile[asan]&quot;:{&quot;require&quot;:&quot;asan&quot;,&quot;input_file&quot;:&quot;stderr.txt&quot;,&quot;fast&quot;:true}},&quot;prepare&quot;:[&quot;compile&quot;],&quot;tests&quot;:[{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;top_of_file&quot;,&quot;code&quot;:&quot;\/\/---------------------------------------------------------------------------------------------------------------\n\/\/ Tehnike programiranja - Akademska 2023\/2024 godina\n\/\/ Zadaca 2 - Zadatak 2\n\/\/ Odgovorni asistent: Vahidin Hasi\u0107 - vhasic1@etf.unsa.ba\n\/\/ Za sva tehnicka pitanja vezana za autotestove za zadatak 2, obratite se na navedeni mail.\n\/\/---------------------------------------------------------------------------------------------------------------&quot;},{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;_main();&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:\n 12   9  45  -4  -3 -15 \n  0 -15   6   0   5  -2 \n  0   0   0  20  15  75 \n  0   0   0   0 -25  10&quot;,&quot;Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:\n 12   9  45  -4  -3 -15 \n  0 -15   6  -0   5  -2 \n  0   0   0  20  15  75 \n  0  -0   0   0 -25  10&quot;],&quot;environment&quot;:{&quot;stdin&quot;:&quot;2 2\n3 -1 0 5\n2 3\n4 3 15 0 -5 2\n&quot;}}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 1&quot;,&quot;id&quot;:1},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    std::vector<std::vector<int>> mat1 = {{1, 2}, {3}};\n    std::vector<std::vector<int>> mat2 = {{4, 5}, {6, 7}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &amp;e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n\n    mat1 = std::vector<std::vector<int>> {{1, 2}, {3, 4}};\n    mat2 = std::vector<std::vector<int>>{{5}, {6, 7}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &amp;e)\n    {\n        std::cout << e.what() << std::endl;\n    }\n\n    mat1 = std::vector<std::vector<int>> {};\n    mat2 = std::vector<std::vector<int>>{};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { return x * y; });\n    }\n    catch (std::domain_error &amp;e)\n    {\n        std::cout << e.what() << std::endl;\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;Prvi parametar nema formu matrice\nDrugi parametar nema formu matrice\nParametri nemaju formu matrice&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 2&quot;,&quot;id&quot;:2,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    std::vector<int> m1[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n    std::vector<int> m2[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)\n                                                    { return x * y; });\n    for (const auto &amp;row : result)\n    {\n        for (const auto &amp;elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;1 2 3 2 4 6 3 6 9\n4 5 6 8 10 12 12 15 18\n7 8 9 14 16 18 21 24 27\n4 8 12 5 10 15 6 12 18\n16 20 24 20 25 30 24 30 36\n28 32 36 35 40 45 42 48 54 \n7 14 21 8 16 24 9 18 27\n28 35 42 32 40 48 36 45 54\n49 56 63 56 64 72 63 72 81&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 3&quot;,&quot;id&quot;:3,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    std::vector<std::vector<int>> mat1 = {{3, -1}, {0, 5}};\n    std::vector<std::vector<int>> mat2 = {{4, 3, 15}, {0, -5, 2}};\n    try\n    {\n        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                        { if (y == 0) throw std::runtime_error(\&quot;Dijeljenje s nulom\&quot;);\n                                                            return x \/ y; });\n    }\n    catch (std::runtime_error &amp;e)\n    {\n        std::cout << e.what() << std::endl;\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;Neocekivani problemi pri racunanju&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 4&quot;,&quot;id&quot;:4,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    int m = 2, n = 3;\n    int p = 3, q = 4;\n    int mat1[2][3] = {{3, 5, 2}, {4, 0, -1}};\n    int mat2[3][4] = {{1, 4, -2, 3}, {0, 5, 4, 1}, {2, 0, 0, 3}};\n\n    std::vector<std::vector<int>> kronekerovProizvod = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)\n                                                                                         { return x * y; });\n\n    for (int i = 0; i < m * p; i++)\n    {\n        for (int j = 0; j < n * q; j++)\n        {\n            std::cout << kronekerovProizvod[i][j] << \&quot; \&quot;;\n        }\n        std::cout << std::endl;\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;3 12 -6 9 5 20 -10 15 2 8 -4 6\n0 15 12 3 0 25 20 5 0 10 8 2\n6 0 0 9 10 0 0 15 4 0 0 6\n4 16 -8 12 0 0 0 0 -1 -4 2 -3\n0 20 16 4 0 0 0 0 0 -5 -4 -1\n8 0 0 12 0 0 0 0 -2 0 0 -3&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 5&quot;,&quot;id&quot;:5,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    std::deque<std::deque<int>> mat1 = {{3, -1}, {1, 5}};\n    std::deque<std::deque<double>> mat2 = {{4.2, 3.1, 15.4}, {1.02, -5.8, 2.6}};\n    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)\n                                                    { return x + y; });\n    for (const auto &amp;row : result)\n    {\n        for (const auto &amp;elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;7.2 6.1 18.4 3.2 2.1 14.4\n4.02 -2.8 5.6 0.02 -6.8 1.6\n5.2 4.1 16.4 9.2 8.1 20.4\n2.02 -4.8 3.6 6.02 -0.8 7.6&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 6&quot;,&quot;id&quot;:6},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    int mat1[2][2] = {{3, -1}, {4, 5}};\n    std::deque<std::deque<double>> mat2 = {{4.5, 3.5, 15.5}, {0.5, -5.5, 2.5}};\n    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)\n                                                    { return x * y; });\n    for (const auto &amp;row : result)\n    {\n        for (const auto &amp;elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;13.5 10.5 46.5 -4.5 -3.5 -15.5 \n1.5 -16.5 7.5 -0.5 5.5 -2.5\n18 14 62 22.5 17.5 77.5\n2 -22 10 2.5 -27.5 12.5&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 7&quot;,&quot;id&quot;:7,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;above_main&quot;,&quot;code&quot;:&quot;#include <list>\n\ntemplate <typename TipElemenata>\nclass Pristupnik\n{\n    std::list<TipElemenata> &amp;red;\n\npublic:\n    Pristupnik(std::list<TipElemenata> &amp;red) : red(red) {}\n    TipElemenata &amp;operator[](int j) { return *std::next(red.begin(), j); }\n    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }\n    auto begin() const { return red.begin(); }\n    auto end() const { return red.end(); }\n};\n\ntemplate <typename TipElemenata>\nclass SugavaMatrica\n{\n    std::list<std::list<TipElemenata>> mat;\n\npublic:\n    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}\n    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    auto begin() const { return mat.begin(); }\n    auto end() const { return mat.end(); }\n};&quot;},{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    SugavaMatrica<int> m1(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m1[i][j] = (i + 1) * (j + 1);\n\n    SugavaMatrica<int> m2(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m2[i][j] = (i + 1) + (j + 1);\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)\n                                                    { return x * y; });\n    for (const auto &amp;row : result)\n    {\n        for (const auto &amp;elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;2 3 4 4 6 8 6 9 12\n3 4 5 6 8 10 9 12 15\n4 5 6 8 10 12 12 15 18\n4 6 8 8 12 16 12 18 24\n6 8 10 12 16 20 18 24 30\n8 10 12 16 20 24 24 30 36\n6 9 12 12 18 24 18 27 36\n9 12 15 18 24 30 27 36 45\n12 15 18 24 30 36 36 45 54&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 8&quot;,&quot;id&quot;:8,&quot;options&quot;:[&quot;hidden&quot;]},{&quot;tools&quot;:[{&quot;patch&quot;:[{&quot;position&quot;:&quot;above_main&quot;,&quot;code&quot;:&quot;#include <list>\n\ntemplate <typename TipElemenata>\nclass Pristupnik\n{\n    std::list<TipElemenata> &amp;red;\n\npublic:\n    Pristupnik(std::list<TipElemenata> &amp;red) : red(red) {}\n    TipElemenata &amp;operator[](int j) { return *std::next(red.begin(), j); }\n    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }\n    auto begin() const { return red.begin(); }\n    auto end() const { return red.end(); }\n};\n\ntemplate <typename TipElemenata>\nclass SugavaMatrica\n{\n    std::list<std::list<TipElemenata>> mat;\n\npublic:\n    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}\n    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }\n    auto begin() const { return mat.begin(); }\n    auto end() const { return mat.end(); }\n};&quot;},{&quot;position&quot;:&quot;main&quot;,&quot;code&quot;:&quot;    SugavaMatrica<int> m1(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m1[i][j] = (i + 1) * (j + 1);\n\n    SugavaMatrica<double> m2(3, 3);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            m2[i][j] = (i + 2.5) + (j + 1);\n\n    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, double y)\n                                                    { return x + y; });\n    for (const auto &amp;row : result)\n    {\n        for (const auto &amp;elem : row)\n            std::cout << elem << ' ';\n        std::cout << '\\n';\n    }&quot;}]},&quot;compile[debug]&quot;,{&quot;execute&quot;:{&quot;expect&quot;:[&quot;4.5 5.5 6.5 5.5 6.5 7.5 6.5 7.5 8.5\n5.5 6.5 7.5 6.5 7.5 8.5 7.5 8.5 9.5\n6.5 7.5 8.5 7.5 8.5 9.5 8.5 9.5 10.5\n5.5 6.5 7.5 7.5 8.5 9.5 9.5 10.5 11.5\n6.5 7.5 8.5 8.5 9.5 10.5 10.5 11.5 12.5\n7.5 8.5 9.5 9.5 10.5 11.5 11.5 12.5 13.5\n6.5 7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5\n7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5\n8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5 16.5&quot;]}},&quot;debug&quot;,&quot;profile[asan]&quot;],&quot;name&quot;:&quot;Test 9&quot;,&quot;id&quot;:9,&quot;options&quot;:[&quot;hidden&quot;]}],&quot;code&quot;:&quot;200&quot;}">
