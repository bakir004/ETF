Test 1: Nije skriven - Koristi vasu main() funkciju i stdin ulaz

Ulaz:

2 2
3 -1 0 5
2 3
4 3 15 0 -5 2

Ovaj autotest ima vise validnih izlaza!
Izlaz 1:

Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:
 12   9  45  -4  -3 -15 
  0 -15   6   0   5  -2 
  0   0   0  20  15  75 
  0   0   0   0 -25  10

Izlaz 2:

Unesite dimenzije prve matrice: Unesite elemente prve matrice: Unesite dimenzije druge matrice: Unesite elemente druge matrice: Njihov Kroneckerov proizvod glasi:
 12   9  45  -4  -3 -15 
  0 -15   6  -0   5  -2 
  0   0   0  20  15  75 
  0  -0   0   0 -25  10

########################################################################
########################################################################
########################################################################

Test 2: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    std::vector<std::vector<int>> mat1 = {{1, 2}, {3}};
    std::vector<std::vector<int>> mat2 = {{4, 5}, {6, 7}};
    try
    {
        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)
                                                        { return x * y; });
    }
    catch (std::domain_error &e)
    {
        std::cout << e.what() << std::endl;
    }

    mat1 = std::vector<std::vector<int>> {{1, 2}, {3, 4}};
    mat2 = std::vector<std::vector<int>>{{5}, {6, 7}};
    try
    {
        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)
                                                        { return x * y; });
    }
    catch (std::domain_error &e)
    {
        std::cout << e.what() << std::endl;
    }

    mat1 = std::vector<std::vector<int>> {};
    mat2 = std::vector<std::vector<int>>{};
    try
    {
        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)
                                                        { return x * y; });
    }
    catch (std::domain_error &e)
    {
        std::cout << e.what() << std::endl;
    }

    return 0;
}

========================================================================

Izlaz:

Prvi parametar nema formu matrice
Drugi parametar nema formu matrice
Parametri nemaju formu matrice

########################################################################
########################################################################
########################################################################

Test 3: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    std::vector<int> m1[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    std::vector<int> m2[3] = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)
                                                    { return x * y; });
    for (const auto &row : result)
    {
        for (const auto &elem : row)
            std::cout << elem << ' ';
        std::cout << '\n';
    }

    return 0;
}

========================================================================

Izlaz:

1 2 3 2 4 6 3 6 9
4 5 6 8 10 12 12 15 18
7 8 9 14 16 18 21 24 27
4 8 12 5 10 15 6 12 18
16 20 24 20 25 30 24 30 36
28 32 36 35 40 45 42 48 54 
7 14 21 8 16 24 9 18 27
28 35 42 32 40 48 36 45 54
49 56 63 56 64 72 63 72 81

########################################################################
########################################################################
########################################################################

Test 4: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    std::vector<std::vector<int>> mat1 = {{3, -1}, {0, 5}};
    std::vector<std::vector<int>> mat2 = {{4, 3, 15}, {0, -5, 2}};
    try
    {
        auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)
                                                        { if (y == 0) throw std::runtime_error("Dijeljenje s nulom");
                                                            return x / y; });
    }
    catch (std::runtime_error &e)
    {
        std::cout << e.what() << std::endl;
    }

    return 0;
}

========================================================================

Izlaz:

Neocekivani problemi pri racunanju

########################################################################
########################################################################
########################################################################

Test 5: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    int m = 2, n = 3;
    int p = 3, q = 4;
    int mat1[2][3] = {{3, 5, 2}, {4, 0, -1}};
    int mat2[3][4] = {{1, 4, -2, 3}, {0, 5, 4, 1}, {2, 0, 0, 3}};

    std::vector<std::vector<int>> kronekerovProizvod = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, int y)
                                                                                         { return x * y; });

    for (int i = 0; i < m * p; i++)
    {
        for (int j = 0; j < n * q; j++)
        {
            std::cout << kronekerovProizvod[i][j] << " ";
        }
        std::cout << std::endl;
    }

    return 0;
}

========================================================================

Izlaz:

3 12 -6 9 5 20 -10 15 2 8 -4 6
0 15 12 3 0 25 20 5 0 10 8 2
6 0 0 9 10 0 0 15 4 0 0 6
4 16 -8 12 0 0 0 0 -1 -4 2 -3
0 20 16 4 0 0 0 0 0 -5 -4 -1
8 0 0 12 0 0 0 0 -2 0 0 -3

########################################################################
########################################################################
########################################################################

Test 6: Nije skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    std::deque<std::deque<int>> mat1 = {{3, -1}, {1, 5}};
    std::deque<std::deque<double>> mat2 = {{4.2, 3.1, 15.4}, {1.02, -5.8, 2.6}};
    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)
                                                    { return x + y; });
    for (const auto &row : result)
    {
        for (const auto &elem : row)
            std::cout << elem << ' ';
        std::cout << '\n';
    }

    return 0;
}

========================================================================

Izlaz:

7.2 6.1 18.4 3.2 2.1 14.4
4.02 -2.8 5.6 0.02 -6.8 1.6
5.2 4.1 16.4 9.2 8.1 20.4
2.02 -4.8 3.6 6.02 -0.8 7.6

########################################################################
########################################################################
########################################################################

Test 7: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

int main() {
    int mat1[2][2] = {{3, -1}, {4, 5}};
    std::deque<std::deque<double>> mat2 = {{4.5, 3.5, 15.5}, {0.5, -5.5, 2.5}};
    auto result = GeneraliziraniKroneckerovProizvod(mat1, mat2, [](int x, double y)
                                                    { return x * y; });
    for (const auto &row : result)
    {
        for (const auto &elem : row)
            std::cout << elem << ' ';
        std::cout << '\n';
    }

    return 0;
}

========================================================================

Izlaz:

13.5 10.5 46.5 -4.5 -3.5 -15.5 
1.5 -16.5 7.5 -0.5 5.5 -2.5
18 14 62 22.5 17.5 77.5
2 -22 10 2.5 -27.5 12.5

########################################################################
########################################################################
########################################################################

Test 8: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

#include <list>

template <typename TipElemenata>
class Pristupnik
{
    std::list<TipElemenata> &red;

public:
    Pristupnik(std::list<TipElemenata> &red) : red(red) {}
    TipElemenata &operator[](int j) { return *std::next(red.begin(), j); }
    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }
    auto begin() const { return red.begin(); }
    auto end() const { return red.end(); }
};

template <typename TipElemenata>
class SugavaMatrica
{
    std::list<std::list<TipElemenata>> mat;

public:
    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}
    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }
    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }
    auto begin() const { return mat.begin(); }
    auto end() const { return mat.end(); }
};

int main() {
    SugavaMatrica<int> m1(3, 3);
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            m1[i][j] = (i + 1) * (j + 1);

    SugavaMatrica<int> m2(3, 3);
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            m2[i][j] = (i + 1) + (j + 1);

    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, int y)
                                                    { return x * y; });
    for (const auto &row : result)
    {
        for (const auto &elem : row)
            std::cout << elem << ' ';
        std::cout << '\n';
    }

    return 0;
}

========================================================================

Izlaz:

2 3 4 4 6 8 6 9 12
3 4 5 6 8 10 9 12 15
4 5 6 8 10 12 12 15 18
4 6 8 8 12 16 12 18 24
6 8 10 12 16 20 18 24 30
8 10 12 16 20 24 24 30 36
6 9 12 12 18 24 18 27 36
9 12 15 18 24 30 27 36 45
12 15 18 24 30 36 36 45 54

########################################################################
########################################################################
########################################################################

Test 9: Skriven
Koristi svoju main() funckiju

Evo kako izgleda program nakon spajanja njihovog i vaseg koda:
========================================================================

// Vas kod ide ovdje

#include <list>

template <typename TipElemenata>
class Pristupnik
{
    std::list<TipElemenata> &red;

public:
    Pristupnik(std::list<TipElemenata> &red) : red(red) {}
    TipElemenata &operator[](int j) { return *std::next(red.begin(), j); }
    TipElemenata operator[](int j) const { return *std::next(red.begin(), j); }
    auto begin() const { return red.begin(); }
    auto end() const { return red.end(); }
};

template <typename TipElemenata>
class SugavaMatrica
{
    std::list<std::list<TipElemenata>> mat;

public:
    SugavaMatrica(int m = 0, int n = 0) : mat(m, std::list<TipElemenata>(n)) {}
    Pristupnik<TipElemenata> operator[](int i) { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }
    const Pristupnik<TipElemenata> operator[](int i) const { return Pristupnik<TipElemenata>(*std::next(mat.begin(), i)); }
    auto begin() const { return mat.begin(); }
    auto end() const { return mat.end(); }
};

int main() {
    SugavaMatrica<int> m1(3, 3);
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            m1[i][j] = (i + 1) * (j + 1);

    SugavaMatrica<double> m2(3, 3);
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            m2[i][j] = (i + 2.5) + (j + 1);

    auto result = GeneraliziraniKroneckerovProizvod(m1, m2, [](int x, double y)
                                                    { return x + y; });
    for (const auto &row : result)
    {
        for (const auto &elem : row)
            std::cout << elem << ' ';
        std::cout << '\n';
    }

    return 0;
}

========================================================================

Izlaz:

4.5 5.5 6.5 5.5 6.5 7.5 6.5 7.5 8.5
5.5 6.5 7.5 6.5 7.5 8.5 7.5 8.5 9.5
6.5 7.5 8.5 7.5 8.5 9.5 8.5 9.5 10.5
5.5 6.5 7.5 7.5 8.5 9.5 9.5 10.5 11.5
6.5 7.5 8.5 8.5 9.5 10.5 10.5 11.5 12.5
7.5 8.5 9.5 9.5 10.5 11.5 11.5 12.5 13.5
6.5 7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5
7.5 8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5
8.5 9.5 10.5 11.5 12.5 13.5 14.5 15.5 16.5

########################################################################
########################################################################
########################################################################

