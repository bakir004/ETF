\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[bosnian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{float}

\geometry{margin=2.5cm}

% Definisanje stila za Julia kod
\lstdefinestyle{julia}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=4,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={\%*}{*)},
    morekeywords={function,end,if,else,elseif,for,while,return,using,println,error}
}

\title{\textbf{Izvještaj - Laboratorijska vježba 4} \\ 
\large Simplex - opšti oblik LP uz korištenje AI alata}
\author{Bakir Činjarević 19705 \& Amar Handanagić 19089}
\date{04.11.2025.}

\begin{document}

\maketitle

\section{Uvod}

Cilj ove laboratorijske vježbe je proširiti rješenje klasičnog Simplex problema na opšti oblik LP, sa različitim funkcijama cilja (maksimizacija/minimizacija) i ograničenjima tipa $\leq$, $=$, $\geq$, uključujući negativne $b_i$. Vježba uključuje korištenje AI alata (Claude) za pomoć u pisanju, testiranju i razumijevanju koda.

Opšti oblik linearnog programiranja glasi:
\begin{equation}
\begin{aligned}
\arg\max/\min \quad & Z(x) = c^T x \\
\text{p.o.} \quad & Ax \{\leq / = / \geq\} b \\
& x \{\geq 0\} \text{ (pretpostavka za sve varijable)}
\end{aligned}
\end{equation}

\section{Prompt korišten za AI alat}

Za implementaciju Simplex metode za opšti oblik LP problema u Juliji korišten je sljedeći prompt:

\begin{quote}
\textit{``Implementiraj Simplex metodu u programskom jeziku Julia za rješavanje opšteg oblika problema linearnog programiranja. Funkcija treba da se zove \texttt{rijesi\_simplex(goal, A, b, c, csigns, vsigns)} i prima:}

\begin{itemize}
\item \textit{\texttt{goal} - string "max" ili "min"}
\item \textit{\texttt{A} - matrica koeficijenata ograničenja}
\item \textit{\texttt{b} - vektor desnih strana}
\item \textit{\texttt{c} - vektor koeficijenata funkcije cilja}
\item \textit{\texttt{csigns} - vektor sa +1 ($\geq$), -1 ($\leq$), 0 ($=$)}
\item \textit{\texttt{vsigns} - vektor sa +1 (nenegativna), -1 (nepozitivna), 0 (neograničena)}

\textit{Funkcija treba da:}
\item \textit{Koristi Big-M metodu za rješavanje ograničenja tipa $=$ i $\geq$}
\item \textit{Transformiše negativne $b_i$ množenjem sa -1}
\item \textit{Transformiše varijable prema \texttt{vsigns}}
\item \textit{Implementira dvofaznu metodu: Faza 1 (eliminacija vještačkih varijabli), Faza 2 (optimizacija)}
\item \textit{Detektuje probleme bez rješenja (kada vještačke varijable nisu nule)}
\item \textit{Detektuje neograničene probleme}
\item \textit{Ispisuje svaku iteraciju tabele}
\item \textit{Vraća optimalno rješenje x, vrijednost funkcije cilja Z, i status}
\end{itemize}
\end{quote}

\section{Generisani kod}

Kompletan Julia kod za implementaciju Simplex metode za opšti oblik nalazi se u priloženom \texttt{.jl} fajlu. Ključni dijelovi implementacije su:

\textbf{1. Transformacija negativnih $b_i$:}

\begin{lstlisting}[style=julia, caption={Transformacija negativnih bi}]
# Transformacija negativnih bi
A_transformed = copy(A)
b_transformed = copy(b)
csigns_transformed = copy(csigns)

for i in 1:m
    if b_transformed[i] < 0
        A_transformed[i, :] .*= -1
        b_transformed[i] *= -1
        csigns_transformed[i] *= -1  # ≤ postaje ≥ i obrnuto
    end
end
\end{lstlisting}

\textbf{2. Kreiranje početne tabele sa Big-M metodom:}

\begin{lstlisting}[style=julia, caption={Kreiranje tabele sa Big-M metodom}]
# Brojanje vještačkih varijabli potrebnih
num_artificial = 0
artificial_indices = Int[]

for i in 1:m
    if csigns_transformed[i] == 0  # =
        num_artificial += 1
        push!(artificial_indices, i)
    elseif csigns_transformed[i] == 1  # >=
        num_artificial += 1
        push!(artificial_indices, i)
    end
end

# Kreiranje početne tabele
total_vars = n + m + num_artificial
tableau = zeros(m + 2, total_vars + 1)  # +2 reda: Z i W (Big-M)

# Dodavanje slack varijabli (za ≤ ograničenja)
# Dodavanje vještačkih varijabli (za = i ≥ ograničenja)
\end{lstlisting}

\textbf{3. Faza 1: Eliminacija vještačkih varijabli:}

\begin{lstlisting}[style=julia, caption={Faza 1 - Eliminacija vještačkih varijabli}]
# Faza 1: Eliminacija vještačkih varijabli (Big-M metoda)
while iteration < max_iterations && !phase1_complete
    # Provjera da li su sve vještačke varijable izbačene iz baze
    artificial_in_basis = false
    for i in 1:m
        if basic_vars[i] > n + m
            artificial_in_basis = true
            break
        end
    end
    
    if !artificial_in_basis
        phase1_complete = true
        break
    end
    
    # Optimizacija W funkcije (Big-M)
    # Pivot operacije...
end

# Provjera izvodljivosti
if !phase1_complete
    # Provjeri da li su sve vještačke varijable jednake nuli
    # Ako nisu, problem nema rješenje (INFEASIBLE)
end
\end{lstlisting}

\textbf{4. Faza 2: Optimizacija originalne funkcije cilja:}

\begin{lstlisting}[style=julia, caption={Faza 2 - Optimizacija funkcije cilja}]
# Faza 2: Optimizacija originalne funkcije cilja Z
while phase2_iteration < max_iterations
    # Koristimo Z red (m+1) za optimizaciju
    objective_row = m + 1
    reduced_costs = tableau[objective_row, 1:(n+m)]
    
    # Provjera optimalnosti
    if goal == "max"
        if all(reduced_costs .>= -1e-10)
            # Optimalno rješenje pronađeno
            # Transformacija nazad na originalne varijable
            return x, Z, "OPTIMAL"
        end
    end
    
    # Pivot operacije...
end
\end{lstlisting}

\section{Test primjeri}

\subsection{Test primjer 1: Minimizacija sa ≥ ograničenjima}

\textbf{Formulacija problema:}
\begin{equation}
\begin{aligned}
\min \quad & Z = 2x_1 + 3x_2 \\
\text{p.o.} \quad & x_1 + x_2 \geq 3 \\
& x_1 + 2x_2 \geq 4 \\
& x_1, x_2 \geq 0
\end{aligned}
\end{equation}

\textbf{Ulazni parametri:}
\begin{lstlisting}[style=julia]
A1 = [1.0 1.0; 1.0 2.0]
b1 = [3.0, 4.0]
c1 = [2.0, 3.0]
csigns1 = [1, 1]  # >=, >=
vsigns1 = [1, 1]  # >= 0, >= 0
x1, Z1, status1 = rijesi_simplex("min", A1, b1, c1, csigns1, vsigns1)
\end{lstlisting}

\textbf{Ručno rješavanje - Transformacija u standardni oblik:}

Za minimizaciju sa $\geq$ ograničenjima, koristimo Big-M metodu:
\begin{itemize}
\item Oduzimamo surplus varijable: $x_1 + x_2 - s_1 = 3$
\item Dodajemo vještačke varijable: $x_1 + x_2 - s_1 + a_1 = 3$
\item U funkciju cilja dodajemo: $M \cdot a_1$ (za min, $M > 0$)
\end{itemize}

\textbf{Početna Simplex tabela:}

\begin{table}[H]
\centering
\begin{tabular}{|c|cc|cc|c|}
\hline
Bazna var & $x_1$ & $x_2$ & $s_1$ & $a_1$ & RHS \\
\hline
$a_1$ & 1 & 1 & -1 & 1 & 3 \\
$a_2$ & 1 & 2 & -1 & 0 & 4 \\
\hline
$Z$ & 2 & 3 & 0 & 0 & 0 \\
$W$ (Big-M) & -2M & -3M & 2M & 0 & -7M \\
\hline
\end{tabular}
\caption{Početna tabela - Test primjer 1}
\end{table}

\textbf{Rješenje:}
\begin{itemize}
\item $x_1 = 2$, $x_2 = 1$
\item $Z = 7$
\item Status: \textbf{OPTIMAL}
\end{itemize}

\textbf{Interpretacija:} Problem minimizacije sa $\geq$ ograničenjima je uspješno riješen koristeći Big-M metodu. Vještačke varijable su eliminirane u Fazi 1, a optimalno rješenje je pronađeno u Fazi 2.

\subsection{Test primjer 2: Problem bez rješenja}

\textbf{Formulacija problema:}
\begin{equation}
\begin{aligned}
\max \quad & Z = x_1 + x_2 \\
\text{p.o.} \quad & x_1 + x_2 \leq 2 \\
& x_1 + x_2 \geq 5 \\
& x_1, x_2 \geq 0
\end{aligned}
\end{equation}

\textbf{Ulazni parametri:}
\begin{lstlisting}[style=julia]
A2 = [1.0 1.0; 1.0 1.0]
b2 = [2.0, 5.0]
c2 = [1.0, 1.0]
csigns2 = [-1, 1]  # <=, >=
vsigns2 = [1, 1]  # >= 0, >= 0
x2, Z2, status2 = rijesi_simplex("max", A2, b2, c2, csigns2, vsigns2)
\end{lstlisting}

\textbf{Objašnjenje:}

Ovaj problem \textbf{nema rješenje} jer su ograničenja kontradiktorna:
\begin{itemize}
\item $x_1 + x_2 \leq 2$ zahtijeva da je suma varijabli najviše 2
\item $x_1 + x_2 \geq 5$ zahtijeva da je suma varijabli najmanje 5
\end{itemize}

Ova dva zahtjeva se ne mogu istovremeno zadovoljiti.

\textbf{Detekcija u kodu:}

Program detektuje da problem nema rješenje kada, nakon Faze 1 (eliminacije vještačkih varijabli), vještačke varijable nisu sve jednake nuli. To znači da je sistem ograničenja nekonzistentan.

\textbf{Rješenje:}
\begin{itemize}
\item $x = [0, 0]$ (nije definisano)
\item $Z = 0$ (nije definisano)
\item Status: \textbf{INFEASIBLE}
\end{itemize}

\subsection{Test primjer 3: Sa = ograničenjem}

\textbf{Formulacija problema:}
\begin{equation}
\begin{aligned}
\max \quad & Z = 3x_1 + 2x_2 \\
\text{p.o.} \quad & x_1 + x_2 = 4 \\
& 2x_1 + x_2 \leq 6 \\
& x_1, x_2 \geq 0
\end{aligned}
\end{equation}

\textbf{Ulazni parametri:}
\begin{lstlisting}[style=julia]
A3 = [1.0 1.0; 2.0 1.0]
b3 = [4.0, 6.0]
c3 = [3.0, 2.0]
csigns3 = [0, -1]  # =, <=
vsigns3 = [1, 1]  # >= 0, >= 0
x3, Z3, status3 = rijesi_simplex("max", A3, b3, c3, csigns3, vsigns3)
\end{lstlisting}

\textbf{Ručno rješavanje:}

Za ograničenje tipa $=$, dodajemo vještačku varijablu direktno:
\begin{itemize}
\item $x_1 + x_2 + a_1 = 4$ (vještačka varijabla $a_1$)
\item $2x_1 + x_2 + s_1 = 6$ (slack varijabla $s_1$)
\end{itemize}

U funkciju cilja dodajemo $-M \cdot a_1$ (za max, penalizujemo vještačku varijablu).

\textbf{Početna Simplex tabela:}

\begin{table}[H]
\centering
\begin{tabular}{|c|cc|cc|c|}
\hline
Bazna var & $x_1$ & $x_2$ & $s_1$ & $a_1$ & RHS \\
\hline
$a_1$ & 1 & 1 & 0 & 1 & 4 \\
$s_1$ & 2 & 1 & 1 & 0 & 6 \\
\hline
$Z$ & -3 & -2 & 0 & 0 & 0 \\
$W$ (Big-M) & -M-3 & -M-2 & 0 & 0 & -4M \\
\hline
\end{tabular}
\caption{Početna tabela - Test primjer 3}
\end{table}

\textbf{Rješenje:}
\begin{itemize}
\item $x_1 = 2$, $x_2 = 2$
\item $Z = 10$
\item Status: \textbf{OPTIMAL}
\end{itemize}

\textbf{Interpretacija:} Problem sa jednakosnim ograničenjem je uspješno riješen. Vještačka varijabla $a_1$ je eliminirana u Fazi 1, a optimalno rješenje zadovoljava i jednakosno ograničenje $x_1 + x_2 = 4$.

\section{Diskusija o korištenju AI alata}

\subsection{Pozitivne strane}

\begin{enumerate}
\item \textbf{Strukturiranje kompleksnog problema}: AI alat je pomogao u organizaciji kompleksne logike za opšti oblik LP problema, uključujući transformacije varijabli, Big-M metodu i dvofazni pristup.

\item \textbf{Implementacija Big-M metode}: AI je generisao kod za Big-M metodu sa pravilnim rukovanjem vještačkim varijablama i eliminacijom iz funkcije cilja.

\item \textbf{Detekcija edge cases}: Kod automatski detektuje probleme bez rješenja provjeravajući da li su vještačke varijable jednake nuli nakon Faze 1.

\item \textbf{Transformacije}: AI je pomogao u implementaciji transformacija za negativne $b_i$ i različite znakove varijabli.

\item \textbf{Dvofazni pristup}: Generisani kod jasno razdvaja Fazu 1 (eliminacija vještačkih varijabli) i Fazu 2 (optimizacija), što olakšava razumijevanje i debugovanje.
\end{enumerate}

\subsection{Negativne strane}

\begin{enumerate}
\item \textbf{Kompleksnost transformacija varijabli}: AI generisani kod za transformacije varijabli prema \texttt{vsigns} je bio dosta kompleksan i zahtijevao je dodatno testiranje i verifikaciju.

\item \textbf{Big-M numerička stabilnost}: Kod koristi fiksnu vrijednost $M = 10^6$, što može dovesti do numeričkih problema kod većih problema. U praksi, bolje je koristiti adaptivnu vrijednost ili dvofaznu metodu bez eksplicitnog $M$.

\item \textbf{Mapiranje varijabli}: Transformacija nazad na originalne varijable nakon optimizacije je bila kompleksna i zahtijevala je dodatno testiranje.

\item \textbf{Potreba za ručnom verifikacijom}: Zbog kompleksnosti opšteg oblika, svaki test primjer je morao biti pažljivo provjeren ručno, što je oduzelo dodatno vrijeme.

\item \textbf{Ograničena podrška za neograničene varijable}: Implementacija za neograničene varijable ($vsigns = 0$) je bila djelomična i zahtijevala bi dodatni rad za potpunu funkcionalnost.
\end{enumerate}

\subsection{Da li je AI pomogao u razumijevanju algoritma?}

\textbf{Djelomično}, sa značajnim rezervama. AI alat je omogućio brzu implementaciju kompleksnog opšteg oblika Simplex metode, što bi inače zahtijevalo znatno više vremena. Međutim, zbog kompleksnosti transformacija i Big-M metode, pravo razumijevanje je došlo tek nakon detaljne analize koda i ručnog rješavanja test primjera.

AI alat je najbolje koristiti kao pomoćno sredstvo za generisanje osnovne strukture koda, ali je neophodno:
\begin{itemize}
\item Pažljivo testirati sve edge cases
\item Ručno verifikovati rezultate
\item Razumjeti svaki korak transformacije
\item Imati dobro razumijevanje teorije Big-M metode i dvofaznog pristupa
\end{itemize}

Kombinacija AI alata za generisanje osnovne strukture i vlastitog ručnog rada za verifikaciju i razumijevanje pokazala se kao najefikasniji pristup.

\section{Zaključak}

Laboratorijska vježba je uspješno demonstrirala proširenje Simplex metode na opšti oblik LP problema uz pomoć AI alata. Sva tri test primjera su dala očekivane rezultate:
\begin{itemize}
\item Primjer 1: Minimizacija sa $\geq$ ograničenjima - optimalno rješenje ($x_1=2, x_2=1, Z=7$)
\item Primjer 2: Problem bez rješenja - status INFEASIBLE
\item Primjer 3: Problem sa $=$ ograničenjem - optimalno rješenje ($x_1=2, x_2=2, Z=10$)
\end{itemize}

Implementacija Big-M metode i dvofaznog pristupa je uspješno riješila probleme sa različitim tipovima ograničenja. Korištenje AI alata je olakšalo proces implementacije, ali je bilo neophodno kritičko razumijevanje i verifikacija rezultata kroz ručno rješavanje primjera.

\end{document}

